# 函数
函数是封装一段代码的逻辑单元，函数的设计应该尽量的保持单一性，即一个函数只负责一个功能。在日常的业务开发中，常常用到的一个函数模型是：

    返回值 函数名 输入参数 输出参数
    int DoSomething(const stirng &arg1, const int arg2, string &output);

一般涉及到远程调用的函数（通过网络请求发起），调用结果实际上包括两部分，返回码和输出信息。例如调用一个身份态校验的函数，返回码表明了此次调用的结果，例如登录成功或者失败。而输出参数则存储了和登录相关的详细信息，例如个人数据或者失败原因。



###参数
下面的代码中，iVal是函数的**形参**，它是一个整型指针。&a是**实参**，它是一个整型的地址。函数执行后会将实参的**值**复制给形参。因此在函数inc中，形参iVal会被初始化为和实参a的地址。

    void inc(int *iVal)
    {
        *iVal ++;
    }

    int a = 0;
    inc(&a);  // a equals 1 

###引用形参
如果函数参数中存在较大的对象，实参复制会付出较大的时间和存储。采用引用参数可以避免这个问题。利用引用参数可以解决下面的问题：

1. 输出参数
2. 避免大的对象实参复制产生的消耗。

> 如果只是因为避免大对象实参复制而使用引用做参数，应该使用const引用。

非const的引用只能与完全相同类型的非const引用关联。例如下面的调用会产生一个错误，因为字符串常量不能与形参匹配：

    int foo(string &str);
    foo("hello"); // err 

相反定义成const引用则即可以接受const也可以接受非 const对象。


###数组参数
数组做为函数实参的时候，会被自动转换为元素类型的指针,下面三个函数声明中效果都是相同的。注意第三个声明方式中，指明的数组长度并不会有什么实际意义。这样的声明有可能造成开发者的误解，认为该函数只接受长度为2的数组作为参数。

    void foo(int* a);
    void foo(int[] a);
    void foo(int[2] a);


###交换两个指针
通过指针参数可以实现交换两个变量的函数，那么如何实现交换两个指针的函数呢？比较直接的答案是使用指针的指针作为参数。实际上通过使用指针引用，实现会更加简洁：

    void swap_ptr(int* &x, int* &y)
    {
        int * temp;
        temp = x;
        x = y;
        y = temp;
    }
其中`int* &x`是一个引用，引用的内容是一个int型指针。


###函数指针
指针不仅可以指向一个普通对象，还可以指向一个函数，下面代码声明了一个函数指针pfunc，指向一个返回值为int参数为const string引用的函数类型。

    int (*pfunc) (const stirng &str);

使用`typedef`可以简化函数指针的定义,完成类型定以后，可以使用PFUN直接定义函数指针。
    
    int fun(const string &str){ /*do somthing*/}
    
    typedef int (*PFUN)(const string &);
    PFUN pfun = fun;
    
    pfun("hello");     //ok
    (*pfun)("hello");  //ok
    fun("hello");      //pk

> 函数名做右值的时候会被解释为对应类型的函数指针

同样作为指针，函数指针也可以作为函数的参数和返回值。


